"""Comprehensive tests for RetryPrimitive (Phase 3).

Generated by ACE + E2B with iterative refinement.
Total scenarios: 2
Strategies learned: 1
"""

# Core Retry Behavior
import asyncio
import random
from typing import Any

import pytest


# Mock tta_sdk components for testing purposes
class WorkflowPrimitive:
    def __init__(self, name):
        self.name = name

    async def execute(self, input_data, context):
        raise NotImplementedError


class WorkflowContext:
    def __init__(self):
        self.data = {}


class RetryStrategy:
    def __init__(self, max_retries: int = 3, delay: float = 1.0):
        self.max_retries = max_retries
        self.delay = delay


class RetryPrimitive:
    def __init__(self, primitive: WorkflowPrimitive, strategy: RetryStrategy = None):
        self.primitive = primitive
        self.strategy = strategy or RetryStrategy()

    async def execute(self, input_data: Any, context: WorkflowContext) -> Any:
        """
        Executes the underlying primitive with retry logic.

        Args:
            input_data: The input data for the primitive.
            context: The workflow context.

        Returns:
            The result of the primitive execution.

        Raises:
            Exception: If the primitive fails after all retry attempts.
        """
        attempts = 0
        while True:
            try:
                return await self.primitive.execute(input_data, context)
            except Exception as e:
                attempts += 1
                if attempts > self.strategy.max_retries:
                    raise e
                await asyncio.sleep(self.strategy.delay)


class MockPrimitive(WorkflowPrimitive):
    def __init__(self, name: str, return_value: Any = None, side_effect: Any = None):
        super().__init__(name)
        self.return_value = return_value
        self.side_effect = side_effect
        self.call_count = 0

    async def execute(self, input_data: Any, context: WorkflowContext) -> Any:
        self.call_count += 1
        if isinstance(self.side_effect, Exception):
            raise self.side_effect
        elif isinstance(self.side_effect, list):
            if self.call_count <= len(self.side_effect):
                effect = self.side_effect[self.call_count - 1]
                if isinstance(effect, Exception):
                    raise effect
                else:
                    return effect
            else:
                return self.return_value  # or raise an exception if retries are exhausted
        else:
            return self.return_value


async def test_success_on_first_attempt():
    """Test that RetryPrimitive succeeds on the first attempt if the underlying primitive succeeds immediately."""
    mock = MockPrimitive("test", return_value={"result": "success"})
    retry = RetryPrimitive(primitive=mock)
    context = WorkflowContext()
    result = await retry.execute("input_data", context)
    assert result == {"result": "success"}
    assert mock.call_count == 1


async def test_success_after_one_retry():
    """Test that RetryPrimitive succeeds after one retry if the underlying primitive fails once then succeeds."""
    mock = MockPrimitive(
        "test", side_effect=[Exception("First attempt fails"), {"result": "success"}]
    )
    retry = RetryPrimitive(primitive=mock)
    context = WorkflowContext()
    result = await retry.execute("input_data", context)
    assert result == {"result": "success"}
    assert mock.call_count == 2


async def test_success_after_two_retries():
    """Test that RetryPrimitive succeeds after two retries if the underlying primitive fails twice then succeeds."""
    mock = MockPrimitive(
        "test",
        side_effect=[
            Exception("First attempt fails"),
            Exception("Second attempt fails"),
            {"result": "success"},
        ],
    )
    retry = RetryPrimitive(primitive=mock)
    context = WorkflowContext()
    result = await retry.execute("input_data", context)
    assert result == {"result": "success"}
    assert mock.call_count == 3


async def test_retry_exhaustion():
    """Test that RetryPrimitive raises an exception when all retries are exhausted and the underlying primitive always fails."""
    mock = MockPrimitive("test", side_effect=Exception("Always fails"))
    retry = RetryPrimitive(primitive=mock, strategy=RetryStrategy(max_retries=2))
    context = WorkflowContext()
    with pytest.raises(Exception, match="Always fails"):
        await retry.execute("input_data", context)
    assert mock.call_count == 3  # max_retries + 1


# Backoff Strategy Tests
import time
from dataclasses import dataclass
from typing import Any, Protocol, runtime_checkable


@runtime_checkable
class WorkflowPrimitive(Protocol):
    """
    A protocol defining the interface for workflow primitives.
    """

    async def execute(self, input_data: Any, context: "WorkflowContext") -> Any:
        """
        Executes the workflow primitive.

        Args:
            input_data (Any): The input data for the primitive.
            context (WorkflowContext): The context in which the primitive is executed.

        Returns:
            Any: The result of the execution.
        """
        raise NotImplementedError


class WorkflowContext:
    """
    A class representing the context in which a workflow is executed.
    """

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


@dataclass
class RetryStrategy:
    max_retries: int = 3
    backoff_base: float = 2.0
    max_backoff: float = 60.0
    jitter: bool = True

    def calculate_delay(self, attempt: int) -> float:
        delay = min(self.backoff_base**attempt, self.max_backoff)
        if self.jitter:
            delay *= 0.5 + random.random()
        return delay


class RetryPrimitive:
    def __init__(
        self,
        primitive: WorkflowPrimitive,
        strategy: RetryStrategy | None = None,
    ) -> None:
        self.primitive = primitive
        self.strategy = strategy or RetryStrategy()

    async def execute(self, input_data: Any, context: WorkflowContext) -> Any:
        # Retries primitive up to max_retries times with exponential backoff
        # Returns result on success, raises last error on exhaustion
        attempts = 0
        while True:
            try:
                return await self.primitive.execute(input_data, context)
            except Exception as e:
                attempts += 1
                if attempts > self.strategy.max_retries:
                    raise e  # Re-raise the last exception
                delay = self.strategy.calculate_delay(attempts)
                await asyncio.sleep(delay)


class MockPrimitive:
    def __init__(self, results: list[Any], exceptions: list[Exception] | None = None):
        self.results = results
        self.exceptions = exceptions or []
        self.call_count = 0

    async def execute(self, input_data: Any, context: WorkflowContext) -> Any:
        if self.call_count < len(self.exceptions):
            exception = self.exceptions[self.call_count]
            self.call_count += 1
            raise exception
        else:
            if self.call_count - len(self.exceptions) < len(self.results):
                result = self.results[self.call_count - len(self.exceptions)]
                self.call_count += 1
                return result
            else:
                # If results are exhausted, return the last result.
                return self.results[-1]


class MockException(Exception):
    pass


@pytest.fixture
def workflow_context():
    return WorkflowContext()


@pytest.mark.asyncio
async def test_exponential_backoff(workflow_context):
    """Test exponential backoff timing with jitter disabled."""
    strategy = RetryStrategy(max_retries=2, backoff_base=2.0, jitter=False)
    mock_primitive = MockPrimitive(results=[1], exceptions=[MockException(), MockException()])
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    # Expected delays: 2.0^1 + 2.0^2 = 2.0 + 4.0 = 6.0
    expected_delay = 6.0
    assert abs(elapsed - expected_delay) < 0.5, f"elapsed={elapsed}, expected={expected_delay}"
    assert mock_primitive.call_count == 3


@pytest.mark.asyncio
async def test_linear_backoff(workflow_context):
    """Test linear backoff timing with jitter disabled."""
    strategy = RetryStrategy(max_retries=2, backoff_base=1.0, jitter=False)
    mock_primitive = MockPrimitive(results=[1], exceptions=[MockException(), MockException()])
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    # Expected delays: 1.0^1 + 1.0^2 = 1.0 + 1.0 = 2.0
    expected_delay = 2.0
    assert abs(elapsed - expected_delay) < 0.5, f"elapsed={elapsed}, expected={expected_delay}"
    assert mock_primitive.call_count == 3


@pytest.mark.asyncio
async def test_constant_backoff(workflow_context):
    """Test constant backoff timing with jitter disabled."""
    strategy = RetryStrategy(max_retries=2, backoff_base=1.0, max_backoff=1.0, jitter=False)
    mock_primitive = MockPrimitive(results=[1], exceptions=[MockException(), MockException()])
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    # Expected delays: min(1.0^1, 1.0) + min(1.0^2, 1.0) = 1.0 + 1.0 = 2.0
    expected_delay = 2.0
    assert abs(elapsed - expected_delay) < 0.5, f"elapsed={elapsed}, expected={expected_delay}"
    assert mock_primitive.call_count == 3


@pytest.mark.asyncio
async def test_jitter_enabled(workflow_context):
    """Test that jitter is enabled and introduces randomness in the backoff."""
    strategy = RetryStrategy(max_retries=2, backoff_base=2.0, jitter=True)
    mock_primitive = MockPrimitive(results=[1], exceptions=[MockException(), MockException()])
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    # With jitter, the elapsed time should be approximately between half and 1.5 times the expected delay without jitter.
    expected_delay_no_jitter = 2.0 + 4.0  # 2.0^1 + 2.0^2 = 6.0
    min_expected_delay = expected_delay_no_jitter * 0.5
    max_expected_delay = expected_delay_no_jitter * 1.5
    assert min_expected_delay < elapsed < max_expected_delay, (
        f"elapsed={elapsed}, min={min_expected_delay}, max={max_expected_delay}"
    )
    assert mock_primitive.call_count == 3


@pytest.mark.asyncio
async def test_jitter_disabled(workflow_context):
    """Test that jitter is disabled and the backoff is predictable."""
    strategy = RetryStrategy(max_retries=2, backoff_base=2.0, jitter=False)
    mock_primitive = MockPrimitive(results=[1], exceptions=[MockException(), MockException()])
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    expected_delay = 2.0 + 4.0  # 2.0^1 + 2.0^2 = 6.0
    assert abs(elapsed - expected_delay) < 0.5, f"elapsed={elapsed}, expected={expected_delay}"
    assert mock_primitive.call_count == 3


@pytest.mark.asyncio
async def test_max_backoff_limit(workflow_context):
    """Test that the max_backoff limit is enforced."""
    strategy = RetryStrategy(max_retries=3, backoff_base=10.0, max_backoff=20.0, jitter=False)
    mock_primitive = MockPrimitive(
        results=[1], exceptions=[MockException(), MockException(), MockException()]
    )
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    start_time = time.time()
    result = await retry.execute(input_data, workflow_context)
    elapsed = time.time() - start_time

    assert result == 1
    # Expected delays: min(10.0^1, 20.0) + min(10.0^2, 20.0) + min(10.0^3, 20.0) = 10.0 + 20.0 + 20.0 = 50.0
    expected_delay = 50.0
    assert abs(elapsed - expected_delay) < 0.5, f"elapsed={elapsed}, expected={expected_delay}"
    assert mock_primitive.call_count == 4


@pytest.mark.asyncio
async def test_retry_exhaustion(workflow_context):
    """Test that the RetryPrimitive raises the last exception when retries are exhausted."""
    strategy = RetryStrategy(max_retries=2, backoff_base=2.0, jitter=False)
    mock_primitive = MockPrimitive(
        results=[], exceptions=[MockException("err1"), MockException("err2"), MockException("err3")]
    )
    retry = RetryPrimitive(mock_primitive, strategy)
    input_data = "test_input"

    with pytest.raises(MockException) as exc_info:
        await retry.execute(input_data, workflow_context)

    assert str(exc_info.value) == "err3"
    assert mock_primitive.call_count == 3
