"""Comprehensive tests for CachePrimitive (Phase 3).

Generated by ACE + E2B with iterative refinement.
Total scenarios: 2
Strategies learned: 2
"""

import asyncio
from collections.abc import Callable
from time import time
from typing import Any
from unittest.mock import AsyncMock

import pytest

from tta_dev_primitives.core.base import WorkflowContext, WorkflowPrimitive


def default_cache_key_fn(input_data: Any, context: WorkflowContext) -> str:
    return str(input_data) + context.correlation_id


@pytest.fixture
def mock_primitive():
    mock = AsyncMock(spec=WorkflowPrimitive)
    mock.execute.return_value = "mock_result"
    return mock


@pytest.fixture
def mock_context():
    return WorkflowContext(correlation_id="test_correlation_id")


class CachePrimitive(WorkflowPrimitive):
    def __init__(
        self,
        primitive: WorkflowPrimitive,
        cache_key_fn: Callable[[Any, WorkflowContext], str],
        ttl_seconds: float = 3600.0,
    ) -> None:
        self.primitive = primitive
        self.cache_key_fn = cache_key_fn
        self.ttl_seconds = ttl_seconds
        self._cache: dict[str, tuple[Any, float]] = {}
        self._stats = {"hits": 0, "misses": 0, "expirations": 0}

    async def execute(self, input_data: Any, context: WorkflowContext) -> Any:
        cache_key = self.cache_key_fn(input_data, context)
        now = time()
        if cache_key in self._cache:
            value, expiry = self._cache[cache_key]
            if now < expiry:
                self._stats["hits"] += 1
                return value
            else:
                self._stats["expirations"] += 1
                del self._cache[cache_key]
        result = await self.primitive.execute(input_data, context)
        self._cache[cache_key] = (result, now + self.ttl_seconds)
        self._stats["misses"] += 1
        return result

    def get_stats(self) -> dict[str, int]:
        return self._stats.copy()


@pytest.mark.asyncio
async def test_cache_miss_on_first_access(mock_primitive, mock_context):
    cache = CachePrimitive(primitive=mock_primitive, cache_key_fn=default_cache_key_fn)
    input_data = "test_data"
    result = await cache.execute(input_data, mock_context)
    assert result == "mock_result"
    stats = cache.get_stats()
    assert stats["hits"] == 0
    assert stats["misses"] == 1
    mock_primitive.execute.assert_called_once_with(input_data, mock_context)


@pytest.mark.asyncio
async def test_cache_hit_on_second_access(mock_primitive, mock_context):
    cache = CachePrimitive(primitive=mock_primitive, cache_key_fn=default_cache_key_fn)
    input_data = "test_data"
    await cache.execute(input_data, mock_context)
    mock_primitive.execute.reset_mock()
    result = await cache.execute(input_data, mock_context)
    assert result == "mock_result"
    stats = cache.get_stats()
    assert stats["hits"] == 1
    assert stats["misses"] == 1
    mock_primitive.execute.assert_not_called()


@pytest.mark.asyncio
async def test_different_cache_keys_result_in_different_cached_values(mock_primitive, mock_context):
    cache = CachePrimitive(primitive=mock_primitive, cache_key_fn=default_cache_key_fn)
    input_data1 = "test_data_1"
    input_data2 = "test_data_2"
    await cache.execute(input_data1, mock_context)
    await cache.execute(input_data2, mock_context)
    stats = cache.get_stats()
    assert stats["hits"] == 0
    assert stats["misses"] == 2
    mock_primitive.execute.assert_any_call(input_data1, mock_context)
    mock_primitive.execute.assert_any_call(input_data2, mock_context)


@pytest.mark.asyncio
async def test_cache_expiration(mock_primitive, mock_context):
    cache = CachePrimitive(
        primitive=mock_primitive, cache_key_fn=default_cache_key_fn, ttl_seconds=0.1
    )
    input_data = "test_data"
    await cache.execute(input_data, mock_context)
    mock_primitive.execute.assert_called_once()
    mock_primitive.execute.reset_mock()
    await asyncio.sleep(0.2)
    await cache.execute(input_data, mock_context)
    mock_primitive.execute.assert_called_once()
    stats = cache.get_stats()
    assert stats["expirations"] == 1


@pytest.mark.asyncio
async def test_custom_cache_key_function(mock_primitive, mock_context):
    def custom_cache_key_fn(input_data: Any, context: WorkflowContext) -> str:
        return f"custom_{input_data}_{context.correlation_id}"

    cache = CachePrimitive(primitive=mock_primitive, cache_key_fn=custom_cache_key_fn)
    input_data = "test_data"
    await cache.execute(input_data, mock_context)
    mock_primitive.execute.assert_called_once_with(input_data, mock_context)
    mock_primitive.execute.reset_mock()
    await cache.execute(input_data, mock_context)
    mock_primitive.execute.assert_not_called()


@pytest.mark.asyncio
async def test_expiration_statistics(mock_primitive, mock_context):
    cache = CachePrimitive(
        primitive=mock_primitive, cache_key_fn=default_cache_key_fn, ttl_seconds=0.1
    )
    input_data = "test_input"
    await cache.execute(input_data, mock_context)
    await asyncio.sleep(0.2)
    await cache.execute(input_data, mock_context)
    await asyncio.sleep(0.2)
    await cache.execute(input_data, mock_context)
    stats = cache.get_stats()
    assert stats["expirations"] == 2
    assert stats["misses"] == 3
    assert stats["hits"] == 0
