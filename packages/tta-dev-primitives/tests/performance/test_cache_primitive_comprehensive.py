"""Comprehensive tests for CachePrimitive.

Generated by ACE + E2B self-learning system.
Total scenarios: 4
Total iterations: 0
Strategies learned: 1
"""

import asyncio
from unittest.mock import AsyncMock, call

import pytest

from tta_dev_primitives.core.base import WorkflowContext
from tta_dev_primitives.performance import CachePrimitive

# Cache Hit and Miss Scenarios


@pytest.mark.asyncio
class TestCacheHitMiss:
    """
    Tests for CachePrimitive to validate cache hit/miss behavior.
    """

    async def test_cache_miss_on_first_access(self):
        """
        Validates that the primitive is executed on the first access (cache miss).
        """
        mock_primitive = AsyncMock(return_value="initial_value")
        cache = CachePrimitive(wrapped_primitive=mock_primitive)
        context = WorkflowContext()

        result = await cache.run(context, key="test_key")

        assert result == "initial_value"
        mock_primitive.assert_called_once_with(context)

    async def test_cache_hit_on_second_access(self):
        """
        Validates that the cached value is returned on the second access (cache hit),
        and the primitive is not executed.
        """
        mock_primitive = AsyncMock(return_value="initial_value")
        cache = CachePrimitive(wrapped_primitive=mock_primitive)
        context = WorkflowContext()

        # First access (cache miss)
        result1 = await cache.run(context, key="test_key")
        assert result1 == "initial_value"
        mock_primitive.assert_called_once_with(context)

        # Second access (cache hit)
        result2 = await cache.run(context, key="test_key")
        assert result2 == "initial_value"
        mock_primitive.assert_called_once_with(context)  # Still only called once

    async def test_multiple_cache_hits_return_same_value(self):
        """
        Validates that multiple cache hits return the same cached value.
        """
        mock_primitive = AsyncMock(return_value="initial_value")
        cache = CachePrimitive(wrapped_primitive=mock_primitive)
        context = WorkflowContext()

        # First access (cache miss)
        result1 = await cache.run(context, key="test_key")
        assert result1 == "initial_value"
        mock_primitive.assert_called_once_with(context)

        # Multiple cache hits
        result2 = await cache.run(context, key="test_key")
        result3 = await cache.run(context, key="test_key")
        result4 = await cache.run(context, key="test_key")

        assert result2 == "initial_value"
        assert result3 == "initial_value"
        assert result4 == "initial_value"
        mock_primitive.assert_called_once_with(context)  # Primitive still called only once

    async def test_different_cache_keys_result_in_different_cached_values(self):
        """
        Validates that different cache keys result in different cached values.
        Each key should trigger a primitive execution.
        """
        mock_primitive = AsyncMock(side_effect=["value1", "value2", "value3"])
        cache = CachePrimitive(wrapped_primitive=mock_primitive)
        context = WorkflowContext()

        result1 = await cache.run(context, key="key1")
        assert result1 == "value1"
        assert mock_primitive.call_count == 1

        result2 = await cache.run(context, key="key2")
        assert result2 == "value2"
        assert mock_primitive.call_count == 2

        result3 = await cache.run(context, key="key3")
        assert result3 == "value3"
        assert mock_primitive.call_count == 3

        mock_primitive.assert_has_calls([call(context), call(context), call(context)])

        # Check cache hits for each key
        result4 = await cache.run(context, key="key1")
        assert result4 == "value1"
        assert mock_primitive.call_count == 3

        result5 = await cache.run(context, key="key2")
        assert result5 == "value2"
        assert mock_primitive.call_count == 3

        result6 = await cache.run(context, key="key3")
        assert result6 == "value3"
        assert mock_primitive.call_count == 3


# TTL Expiration Tests
import time
from collections.abc import Callable
from typing import Any

import pytest
from cachetools import Cache


class CachePrimitive:
    """
    A simple cache primitive with TTL (time-to-live) expiration.
    """

    def __init__(self, maxsize: int = 128, ttl: float = 60):
        """
        Initializes the CachePrimitive.

        Args:
            maxsize: The maximum number of items to store in the cache.
            ttl: The time-to-live for cache entries in seconds.
        """
        self.cache = Cache(maxsize=maxsize)
        self.ttl = ttl
        self.stats = {"hits": 0, "misses": 0, "expirations": 0}
        self.lock = asyncio.Lock()  # Use asyncio.Lock for async operations

    async def get(self, key: Any, func: Callable[[], Any]) -> Any:
        """
        Retrieves a value from the cache.  If the value is not in the cache
        or if it has expired, it calls the provided function to generate the value,
        stores it in the cache, and returns it.

        Args:
            key: The key to retrieve the value for.
            func: A function that generates the value if it's not in the cache or has expired.

        Returns:
            The cached value.
        """
        async with self.lock:  # Use async with for asyncio.Lock
            now = time.time()
            cached_value = self.cache.get(key)

            if cached_value is not None:
                value, expiry_time = cached_value
                if expiry_time > now:
                    self.stats["hits"] += 1
                    return value
                else:
                    # Entry has expired
                    del self.cache[key]  # Remove expired entry
                    self.stats["expirations"] += 1

            # Value not in cache or expired
            self.stats["misses"] += 1
            value = await func()  # Await the async function
            self.cache[key] = (value, now + self.ttl)
            return value


@pytest.mark.asyncio
class TestCacheTTLExpiration:
    """
    Tests for CachePrimitive TTL expiration.
    """

    async def test_cache_return_before_ttl(self):
        """
        Test that cached value is returned before TTL expires.
        """
        ttl = 0.1
        cache = CachePrimitive(ttl=ttl)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        value1 = await cache.get(key, expensive_function)
        assert value1 == "expensive value"
        assert execution_count == 1

        value2 = await cache.get(key, expensive_function)
        assert value2 == "expensive value"
        assert execution_count == 1  # Should not be executed again

    async def test_cache_expires_after_ttl(self):
        """
        Test that cached value expires after TTL seconds.
        """
        ttl = 0.1
        cache = CachePrimitive(ttl=ttl)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        value1 = await cache.get(key, expensive_function)
        assert value1 == "expensive value"
        assert execution_count == 1

        await asyncio.sleep(ttl * 2)  # Wait for TTL to expire

        value2 = await cache.get(key, expensive_function)
        assert value2 == "expensive value"
        assert execution_count == 2  # Should be executed again

    async def test_expired_entry_removed(self):
        """
        Test that expired entry is removed from cache.
        """
        ttl = 0.1
        cache = CachePrimitive(ttl=ttl)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        await cache.get(key, expensive_function)
        assert key in cache.cache

        await asyncio.sleep(ttl * 2)  # Wait for TTL to expire

        await cache.get(key, expensive_function)  # Trigger expiration and re-execution
        assert key in cache.cache

    async def test_new_execution_after_expiration(self):
        """
        Test that new execution happens after expiration.
        """
        ttl = 0.1
        cache = CachePrimitive(ttl=ttl)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        await cache.get(key, expensive_function)
        assert execution_count == 1

        await asyncio.sleep(ttl * 2)  # Wait for TTL to expire

        await cache.get(key, expensive_function)
        assert execution_count == 2  # Should be executed again

    async def test_statistics_track_expirations(self):
        """
        Test that statistics track expirations correctly.
        """
        ttl = 0.1
        cache = CachePrimitive(ttl=ttl)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        await cache.get(key, expensive_function)
        assert cache.stats["expirations"] == 0

        await asyncio.sleep(ttl * 2)  # Wait for TTL to expire

        await cache.get(key, expensive_function)
        assert cache.stats["expirations"] == 1

    @pytest.mark.parametrize("ttl_value", [1, 5])
    async def test_longer_ttl_values(self, ttl_value):
        """Test with longer TTL values."""
        cache = CachePrimitive(ttl=ttl_value)
        execution_count = 0

        async def expensive_function():
            nonlocal execution_count
            execution_count += 1
            return "expensive value"

        key = "test_key"
        await cache.get(key, expensive_function)
        assert execution_count == 1

        await asyncio.sleep(ttl_value / 2)
        await cache.get(key, expensive_function)
        assert execution_count == 1

        await asyncio.sleep(ttl_value)
        await cache.get(key, expensive_function)
        assert execution_count == 2


# Statistics Tracking Tests
import pytest


class CachePrimitive:
    """
    A simple cache primitive with basic statistics.
    """

    def __init__(self, maxsize):
        """
        Initializes the cache with a maximum size.

        Args:
            maxsize (int): The maximum number of items the cache can hold.
        """
        self.cache = {}
        self.maxsize = maxsize
        self.hits = 0
        self.misses = 0
        self.expirations = 0

    def __contains__(self, key):
        """
        Checks if the cache contains a key.

        Args:
            key: The key to check.

        Returns:
            bool: True if the cache contains the key, False otherwise.
        """
        return key in self.cache

    def __getitem__(self, key):
        """
        Retrieves an item from the cache.

        Args:
            key: The key of the item to retrieve.

        Returns:
            The value associated with the key.

        Raises:
            KeyError: If the key is not found in the cache.
        """
        if key in self.cache:
            self.hits += 1
            return self.cache[key]
        else:
            self.misses += 1
            raise KeyError(key)

    def __setitem__(self, key, value):
        """
        Sets an item in the cache.  Simple eviction policy: remove the oldest.

        Args:
            key: The key of the item to set.
            value: The value of the item to set.
        """
        if len(self.cache) >= self.maxsize:
            # Simple eviction: remove the oldest item
            try:
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                self.expirations += 1
            except StopIteration:
                # Cache is empty, nothing to expire
                pass

        self.cache[key] = value

    def __delitem__(self, key):
        """
        Deletes an item from the cache.

        Args:
            key: The key of the item to delete.

        Raises:
            KeyError: If the key is not found in the cache.
        """
        if key in self.cache:
            del self.cache[key]
        else:
            raise KeyError(key)

    def get_stats(self):
        """
        Returns cache statistics.

        Returns:
            dict: A dictionary containing the cache statistics.
        """
        size = len(self.cache)
        hit_rate = 0.0
        if self.hits + self.misses > 0:
            hit_rate = (self.hits / (self.hits + self.misses)) * 100
        return {
            "size": size,
            "hits": self.hits,
            "misses": self.misses,
            "expirations": self.expirations,
            "hit_rate": hit_rate,
        }

    def clear_cache(self):
        """
        Clears the cache, preserving statistics.
        """
        self.cache = {}


class TestCacheStatistics:
    """
    Tests for CachePrimitive statistics.
    """

    @pytest.fixture
    def cache(self):
        """
        Fixture to create a CachePrimitive instance for testing.
        """
        return CachePrimitive(maxsize=3)

    def test_get_stats_structure(self, cache):
        """
        Test that get_stats() returns the correct structure.
        """
        stats = cache.get_stats()
        assert isinstance(stats, dict)
        assert "size" in stats
        assert "hits" in stats
        assert "misses" in stats
        assert "expirations" in stats
        assert "hit_rate" in stats

    def test_hit_count_increments(self, cache):
        """
        Test that the hit count increments on cache hits.
        """
        cache["a"] = 1
        try:
            cache["a"]
            cache["a"]
            cache["a"]
        except KeyError:
            pass  # Should not happen, key is in the cache
        stats = cache.get_stats()
        assert stats["hits"] == 3

    def test_miss_count_increments(self, cache):
        """
        Test that the miss count increments on cache misses.
        """
        try:
            cache["nonexistent"]
        except KeyError:
            pass

        try:
            cache["another_nonexistent"]
        except KeyError:
            pass
        stats = cache.get_stats()
        assert stats["misses"] == 2

    def test_expiration_count_increments(self, cache):
        """
        Test that the expiration count increments when entries expire.
        """
        cache["a"] = 1
        cache["b"] = 2
        cache["c"] = 3
        cache["d"] = 4  # This should cause 'a' to expire
        stats = cache.get_stats()
        assert stats["expirations"] == 1

    def test_hit_rate_calculation(self, cache):
        """
        Test that the hit rate calculation is correct.
        """
        cache["a"] = 1
        try:
            cache["a"]
            cache["b"]
        except KeyError:
            pass

        stats = cache.get_stats()
        assert stats["hits"] == 1
        assert stats["misses"] == 1
        assert stats["hit_rate"] == 50.0

    def test_hit_rate_zero_no_accesses(self, cache):
        """
        Test that the hit rate is 0.0 when there are no accesses yet.
        """
        stats = cache.get_stats()
        assert stats["hit_rate"] == 0.0

    def test_clear_cache_preserves_stats(self, cache):
        """
        Test that clear_cache() resets the cache but preserves statistics.
        """
        cache["a"] = 1
        try:
            cache["a"]
            cache["b"]
        except KeyError:
            pass

        stats_before = cache.get_stats()
        cache.clear_cache()
        stats_after = cache.get_stats()

        assert len(cache.cache) == 0
        assert stats_before["hits"] == stats_after["hits"]
        assert stats_before["misses"] == stats_after["misses"]
        assert stats_before["expirations"] == stats_after["expirations"]


# Edge Cases and Error Handling
import logging
from collections.abc import Callable
from functools import wraps
from typing import Any

import pytest

logging.basicConfig(level=logging.INFO)


class CacheStats:
    """
    A simple class to hold cache statistics.
    """

    def __init__(self):
        self.hits = 0
        self.misses = 0
        self.size = 0

    def __repr__(self):
        return f"CacheStats(hits={self.hits}, misses={self.misses}, size={self.size})"


class CachePrimitive:
    """
    A simple cache implementation with TTL.
    """

    def __init__(self, ttl: int = 60, max_size: int = 1000, key_func: Callable[[Any], str] = str):
        """
        Initializes the cache.

        Args:
            ttl: Time-to-live for cache entries in seconds.
            max_size: Maximum number of entries in the cache.
            key_func: Function to generate cache keys from input arguments.
        """
        self.cache: dict[str, Any] = {}
        self.ttl = ttl
        self.max_size = max_size
        self.key_func = key_func
        self.stats = CacheStats()
        self.lock = asyncio.Lock()

    async def get(self, key: str) -> Any:
        """
        Retrieves a value from the cache.

        Args:
            key: The cache key.

        Returns:
            The cached value, or None if not found or expired.
        """
        async with self.lock:
            if key in self.cache:
                value, expiry = self.cache[key]
                if expiry > time.time():
                    self.stats.hits += 1
                    return value
                else:
                    self.stats.misses += 1
                    del self.cache[key]  # Remove expired entry
                    return None
            else:
                self.stats.misses += 1
                return None

    async def set(self, key: str, value: Any) -> None:
        """
        Sets a value in the cache.

        Args:
            key: The cache key.
            value: The value to cache.
        """
        async with self.lock:
            if len(self.cache) >= self.max_size:
                self._evict_lru()  # Evict least recently used entry
            self.cache[key] = (value, time.time() + self.ttl)
            self.stats.size = len(self.cache)

    def _evict_lru(self) -> None:
        """
        Evicts the least recently used entry from the cache.
        """
        if not self.cache:
            return
        # Find the key with the earliest expiry time
        lru_key = min(self.cache, key=lambda k: self.cache[k][1])
        del self.cache[lru_key]
        self.stats.size = len(self.cache)

    async def cache_decorator(self, func: Callable[..., Any]) -> Callable[..., Any]:
        """
        A decorator to cache the results of a function.

        Args:
            func: The function to cache.

        Returns:
            The wrapped function.
        """

        @wraps(func)
        async def wrapper(*args: Any, **kwargs: Any) -> Any:
            key = self.key_func(*args, **kwargs)
            value = await self.get(key)
            if value is None:
                value = await func(*args, **kwargs)
                await self.set(key, value)
            return value

        return wrapper

    def evict_expired(self) -> None:
        """
        Manually removes expired entries from the cache.
        """
        keys_to_delete = []
        for key, (_value, expiry) in self.cache.items():
            if expiry <= time.time():
                keys_to_delete.append(key)

        for key in keys_to_delete:
            del self.cache[key]
        self.stats.size = len(self.cache)


class TestCacheEdgeCases:
    @pytest.fixture
    def empty_cache(self):
        return CachePrimitive()

    def test_empty_cache_stats(self, empty_cache):
        assert empty_cache.stats.size == 0
        assert empty_cache.stats.hits == 0
        assert empty_cache.stats.misses == 0

    @pytest.mark.asyncio
    async def test_cache_key_function_various_types(self):
        cache = CachePrimitive(key_func=lambda x: str(x))  # Simple str conversion
        key_dict = {"a": 1, "b": 2}
        key_str = "test_string"
        key_int = 123

        await cache.set(cache.key_func(key_dict), "dict_value")
        await cache.set(cache.key_func(key_str), "str_value")
        await cache.set(cache.key_func(key_int), "int_value")

        assert await cache.get(cache.key_func(key_dict)) == "dict_value"
        assert await cache.get(cache.key_func(key_str)) == "str_value"
        assert await cache.get(cache.key_func(key_int)) == "int_value"

    @pytest.mark.asyncio
    async def test_cache_none_input(self):
        cache = CachePrimitive()
        await cache.set("none_key", None)
        assert await cache.get("none_key") is None

    @pytest.mark.asyncio
    async def test_cache_empty_dict_input(self):
        cache = CachePrimitive()
        await cache.set("empty_dict_key", {})
        assert await cache.get("empty_dict_key") == {}

    @pytest.mark.asyncio
    async def test_long_cache_keys(self, caplog):
        cache = CachePrimitive()
        long_key = "a" * 200
        caplog.set_level(logging.INFO)
        await cache.set(long_key, "long_value")

        assert await cache.get(long_key) == "long_value"

    @pytest.mark.asyncio
    async def test_concurrent_access(self):
        cache = CachePrimitive()
        key = "concurrent_key"
        num_tasks = 10

        async def task(task_id: int):
            value = await cache.get(key)
            if value is None:
                # Simulate a long operation
                await asyncio.sleep(0.01)
                value = f"value_from_task_{task_id}"
                await cache.set(key, value)
            return value

        tasks = [task(i) for i in range(num_tasks)]
        results = await asyncio.gather(*tasks)

        # Check that all tasks return the same value (the one that was first computed)
        first_value = results[0]
        for result in results:
            assert result == first_value

    @pytest.mark.asyncio
    async def test_evict_expired_manually(self):
        cache = CachePrimitive(ttl=1)  # Short TTL
        await cache.set("expired_key", "old_value")
        await asyncio.sleep(2)  # Wait for the entry to expire
        cache.evict_expired()
        assert await cache.get("expired_key") is None
        assert cache.stats.size == 0
