# TTA.dev Custom Instructions for Cline CLI

## Critical Project Settings

### Package Manager
**ALWAYS use `uv`, NEVER `pip` or `poetry`**

Commands:
- Install packages: `uv add package-name`
- Sync dependencies: `uv sync --all-extras`
- Run commands: `uv run pytest`, `uv run ruff format .`
- Run Python: `uv run python script.py`

❌ **NEVER use:** `pip install`, `poetry add`, `python -m pip`

### Python Version & Type Hints
- **Python:** 3.11+ required
- **Type hints:** Use `str | None` NOT `Optional[str]`
- **Dicts:** Use `dict[str, Any]` NOT `Dict[str, Any]`

Examples:
```python
# ✅ CORRECT
def process(data: str | None) -> dict[str, Any]:
    ...

# ❌ WRONG
from typing import Optional, Dict
def process(data: Optional[str]) -> Dict[str, Any]:
    ...
```

## Monorepo Structure

TTA.dev is a Python monorepo with 3 production packages:

1. **tta-dev-primitives** - Core workflow primitives
2. **tta-observability-integration** - OpenTelemetry integration
3. **universal-agent-context** - Agent context management

Packages under review (may be archived):
- keploy-framework
- python-pathway
- js-dev-primitives (placeholder)

## TTA.dev Primitives Patterns

### Use Primitives, Not Manual Code

**Always use primitives for workflow patterns:**

```python
# ✅ GOOD - Use primitives
from tta_dev_primitives import SequentialPrimitive

workflow = step1 >> step2 >> step3

# ❌ BAD - Manual async orchestration
async def workflow():
    result1 = await step1()
    result2 = await step2(result1)
    return await step3(result2)
```

### Composition Operators

- `>>` - Sequential execution (output → input)
- `|` - Parallel execution (same input to all)

```python
# Sequential
workflow = input_processor >> transform >> output_formatter

# Parallel
workflow = fast_path | slow_path | cached_path

# Combined
workflow = (
    input_processor >>
    (fast_path | slow_path | cached_path) >>
    aggregator
)
```

### Recovery Patterns

Don't write manual error handling - use recovery primitives:

```python
from tta_dev_primitives.recovery import (
    RetryPrimitive,
    FallbackPrimitive,
    TimeoutPrimitive,
    CompensationPrimitive
)

# ✅ GOOD - Use RetryPrimitive
workflow = RetryPrimitive(
    primitive=api_call,
    max_retries=3,
    backoff_strategy="exponential"
)

# ❌ BAD - Manual retry
async def api_call_with_retry():
    for i in range(3):
        try:
            return await api_call()
        except Exception:
            await asyncio.sleep(2 ** i)
```

### Performance Patterns

```python
from tta_dev_primitives.performance import CachePrimitive

# LRU cache with TTL
cached = CachePrimitive(
    primitive=expensive_llm_call,
    ttl_seconds=3600,
    max_size=1000
)
```

## Anti-Patterns to Avoid

| ❌ Don't Do This | ✅ Do This Instead |
|-----------------|-------------------|
| Manual async orchestration | Use `SequentialPrimitive` |
| Try/except with retry loops | Use `RetryPrimitive` |
| `asyncio.wait_for()` for timeouts | Use `TimeoutPrimitive` |
| Manual caching with dicts | Use `CachePrimitive` |
| Global variables for state | Use `WorkflowContext` |
| `pip install` | Use `uv add` |
| `Optional[T]` type hints | Use `T \| None` |
| Modifying core primitives | Extend via composition |

## Code Quality Standards

### Required Checks Before Commit

```bash
# 1. Format code
uv run ruff format .

# 2. Lint code
uv run ruff check . --fix

# 3. Type check
uvx pyright packages/

# 4. Run tests
uv run pytest -v
```

### Testing Standards

- **100% coverage required** for all new code
- Use `pytest` with `pytest-asyncio`
- Mock external services with `MockPrimitive`
- Test success, failure, and edge cases

```python
# ✅ GOOD - Use MockPrimitive
from tta_dev_primitives.testing import MockPrimitive
import pytest

@pytest.mark.asyncio
async def test_workflow():
    mock_llm = MockPrimitive(return_value={"output": "test"})
    workflow = step1 >> mock_llm >> step3
    result = await workflow.execute(context, input_data)
    assert mock_llm.call_count == 1
```

## WorkflowContext (State Management)

**Always pass state via WorkflowContext:**

```python
from tta_dev_primitives import WorkflowContext

# ✅ GOOD - Use WorkflowContext
context = WorkflowContext(
    correlation_id="req-123",
    data={"user_id": "user-789"}
)
result = await workflow.execute(context, input_data)

# ❌ BAD - Global variables
USER_ID = "user-789"  # Don't use globals
```

## MCP Server Usage

When a task requires external information or capabilities, leverage the installed MCP servers.

### Available Servers and Use Cases

| Server Name | Primary Use Case | Example Tools |
|---|---|---|
| `context7-mcp` | Fetching up-to-date documentation for any library. | `resolve-library-id`, `get-library-docs` |
| `playwright` | Browser automation, web scraping, and end-to-end testing. | `browser_navigate`, `browser_click`, `browser_snapshot` |
| `serena` | Semantic code analysis, symbol search, and code manipulation. | `get_symbols_overview`, `find_symbol` |
| `postman` | Interacting with the Postman API to manage collections and environments. | `run_collection`, `api_lint` |
| `github` | Interacting with the GitHub API for repository and issue management. | `create_issue`, `get_file_contents`, `create_pull_request` |
| `sequential-thinking` | Breaking down complex problems and getting tool recommendations. | `sequentialthinking_tools` |
| `gitmcp` | Accessing documentation and code from GitHub repositories. | `fetch_TTA_dev_documentation`, `search_TTA_dev_code` |

### Workflow

1.  **Identify the need:** Determine if the task requires external data or actions.
2.  **Select the right tool:** Choose the appropriate MCP server and tool based on the task.
3.  **Execute the tool:** Use the `use_mcp_tool` to call the server with the necessary arguments.
4.  **Process the results:** Use the output from the MCP server to complete the task.

## Response Style

- **Be concise and direct** - avoid verbose explanations
- **One sentence for simple questions**
- **Use bullet points instead of paragraphs**
- **Show code examples when relevant**
- **Reference existing files** when possible

## Documentation

When creating/updating documentation:

- ✅ Include working code examples
- ✅ Be specific (reference actual files/classes/functions)
- ✅ Update when code changes
- ✅ Write for developers using the code

See: `.github/instructions/documentation.instructions.md`

## Logseq TODO Management

**ALL agents working on TTA.dev MUST use Logseq for TODOs:**

- **Location:** `logseq/journals/YYYY_MM_DD.md`
- **Tags:** `#dev-todo` (development) or `#user-todo` (learning)
- **Properties:** `type::`, `priority::`, `package::`, `related::`

Example:
```markdown
- TODO Implement CachePrimitive metrics #dev-todo
  type:: implementation
  priority:: high
  package:: tta-observability-integration
  related:: [[TTA Primitives/CachePrimitive]]
```

See: `.github/instructions/logseq-knowledge-base.instructions.md`

## File-Type Specific Instructions

TTA.dev uses path-based instruction files:

| File Pattern | Instruction File | Key Rules |
|--------------|-----------------|-----------|
| `packages/**/src/**/*.py` | `package-source.instructions.md` | Production quality, full types |
| `**/tests/**/*.py` | `tests.instructions.md` | 100% coverage, pytest-asyncio |
| `scripts/**/*.py` | `scripts.instructions.md` | Use primitives for orchestration |
| `**/*.md` | `documentation.instructions.md` | Clear, actionable, with examples |

## Quick Reference

### Common Tasks

```bash
# Install dependency
uv add package-name

# Run tests
uv run pytest -v

# Format code
uv run ruff format .

# Lint code
uv run ruff check . --fix

# Type check
uvx pyright packages/

# Quality check (all)
uv run ruff format . && uv run ruff check . --fix && uvx pyright packages/ && uv run pytest -v
```

### File Locations

- **Core primitives:** `packages/tta-dev-primitives/src/tta_dev_primitives/`
- **Observability:** `packages/tta-observability-integration/src/observability_integration/`
- **Agent context:** `packages/universal-agent-context/src/universal_agent_context/`
- **Examples:** `packages/tta-dev-primitives/examples/`
- **Tests:** `packages/*/tests/`

### Documentation

- **Main instructions:** `AGENTS.md`
- **Primitives catalog:** `PRIMITIVES_CATALOG.md`
- **Getting started:** `GETTING_STARTED.md`
- **MCP servers:** `MCP_SERVERS.md`

---

**Remember:**
1. ALWAYS use `uv`, never `pip` or `poetry`
2. Use `str | None`, never `Optional[str]`
3. Use primitives for all workflow patterns
4. 100% test coverage required
5. Keep responses concise and direct
